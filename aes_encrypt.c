// AES encryption

/*  1. Key Expansion
	2. Initial Round:
		AddRoundKey
	3. Rounds:
		SubBytes
		ShiftRows
		MixColumns
		AddRoundKey
	4. Final Round:
		SubBytes
		ShiftRows
		AddRoundKey
		

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "aes_encrypt_decrypt.h"
#define ROUNDS 9

void rotate(unsigned char* word, int n) {
	unsigned char tmp[4];
	
	switch(n){
		case 1: tmp[0] = word[1];
				tmp[1] = word[2];
				tmp[2] = word[3];
				tmp[3] = word[0];
				break;
		
		case 2: tmp[0] = word[2];
				tmp[1] = word[3];
				tmp[2] = word[0];
				tmp[3] = word[1];
				break;
				
		case 3: tmp[0] = word[3];
				tmp[1] = word[0];
				tmp[2] = word[1];
				tmp[3] = word[2];
				break;
		default: return;
	}
	
	word[0] = tmp[0];
	word[1] = tmp[1];
	word[2] = tmp[2];
	word[3] = tmp[3];
}

void keyExpansionCore(unsigned char* in, int i){
	//rotate left
	rotate(in, 1);
	
	//s_box substitution
	in[0] = sbox[in[0]];
	in[1] = sbox[in[1]];
	in[2] = sbox[in[2]];
	in[3] = sbox[in[3]];
	
	//Rcon raise
	in[0] ^= RCON[i];
	in[1] ^= RCON[i];
	in[2] ^= RCON[i];
	in[3] ^= RCON[i];
}

void keyExpansion(unsigned char key[16], unsigned char expandedKeys[176]) {
	//the first 16 bytes are just the original key
	int i;
	for(i=0; i<16; i++)
		expandedKeys[i] = key[i];
	
	int bytesGenerated = 16;
	int rconIteration = 1;
	unsigned char tmp[4];
	
	while(bytesGenerated < 176){
		//Read last 4 bytes generated from the core:
		for(i=0; i<4; i++){
			tmp[i] = expandedKeys[i + bytesGenerated - 4];
		}
		
		//If it's a new key, perform the core with the last 4 bytes of the previous key.
		if(bytesGenerated % 16 == 0){
			keyExpansionCore(tmp, rconIteration++);
		}
		
		//XOR tmp with the previously generated bytes and store them in expanded keys
		for(i=0; i<4; i++){
			expandedKeys[bytesGenerated] = expandedKeys[bytesGenerated-16] ^ tmp[i];
			bytesGenerated++;
		}
	}
}

void addRoundKey(unsigned char* state, unsigned char* roundKey) {
	int i;
	for(i=0; i<16; i++){
		state[i] ^= roundKey[i];
	}
	
}
void subBytes(unsigned char* state) {
	int i;
	for(i=0; i<16; i++){
		state[i] = sbox[state[i]];
	}
}
void shiftRows(unsigned char* state) {
	rotate(state+4, 1);
	rotate(state+8, 2);
	rotate(state+12, 3);
}

void mixColumns(unsigned char* state) {
	unsigned char tmp[16];
	
	/*	MAP:
		[2	 3	 1	 1
		 1	 2	 3	 1
		 1	 1	 2	 3
		 3	 1	 1	 2]
	*/
	
	tmp[0] = mul_2[state[0]] ^ mul_3[state[4]] ^ state[8] ^ state[12];
	tmp[1] = mul_2[state[1]] ^ mul_3[state[5]] ^ state[9] ^ state[13];
	tmp[2] = mul_2[state[2]] ^ mul_3[state[6]] ^ state[10] ^ state[14];
	tmp[3] = mul_2[state[3]] ^ mul_3[state[7]] ^ state[11] ^ state[15];
	
	tmp[4] = state[0] ^ mul_2[state[4]] ^ mul_3[state[8]] ^ state[12];
	tmp[5] = state[1] ^ mul_2[state[5]] ^ mul_3[state[9]] ^ state[13];
	tmp[6] = state[2] ^ mul_2[state[6]] ^ mul_3[state[10]] ^ state[14];
	tmp[7] = state[3] ^ mul_2[state[7]] ^ mul_3[state[11]] ^ state[15];
	
	tmp[8] = state[0] ^ state[4] ^ mul_2[state[8]] ^ mul_3[state[12]];
	tmp[9] = state[1] ^ state[5] ^ mul_2[state[9]] ^ mul_3[state[13]];
	tmp[10] = state[2] ^ state[6] ^ mul_2[state[10]] ^ mul_3[state[14]];
	tmp[11] = state[3] ^ state[7] ^ mul_2[state[11]] ^ mul_3[state[15]];
	
	tmp[12] = mul_3[state[0]] ^ state[4] ^ state[8] ^ mul_2[state[12]];
	tmp[13] = mul_3[state[1]] ^ state[5] ^ state[9] ^ mul_2[state[13]];
	tmp[14] = mul_3[state[2]] ^ state[6] ^ state[10] ^ mul_2[state[14]];
	tmp[15] = mul_3[state[3]] ^ state[7] ^ state[11] ^ mul_2[state[15]];
	
	int i;
	for(i=0; i<16; i++){
		state[i] = tmp[i];
	}
}

void AES_Encrypt(unsigned char* in, unsigned char* expandedKeys){
	unsigned char state[16];
	int i;
	
	for(i=0; i<16; i++)
		state[i] = in[i];

	addRoundKey(state, expandedKeys);
	expandedKeys += 16;
	
	for(i=0; i<ROUNDS; i++){
		subBytes(state);
		shiftRows(state);
		mixColumns(state);
		addRoundKey(state, expandedKeys);
		expandedKeys += 16;
	}
	
	subBytes(state);
	shiftRows(state);
	addRoundKey(state, expandedKeys);
	
	for(i=0; i<16; i++)
		in[i] = state[i];
}


int main(int argc, char** argv){
	switch(argc){
		case 2: break;
		default: printf("Usage: encrypt <path> <key>\n");
				 return -1;
	}
	
	char* filepath = argv[0];
	unsigned char key[16];
	unsigned char expandedKeys[176];
	int j;
	for(j=0; j<16; j++)
		key[j] = argv[1][j];
	
	
	
	FILE* fptr;
	errno_t err = fopen_s(&fptr, filepath, "rb");
	if(err == 22){
		printf("Error: file not accessible\n");
		return -1;
	}
	
	unsigned char* message = malloc(sizeof(unsigned char)*128);
	int len = 0;
	
	size_t check = fread(message, sizeof(unsigned char), 128, fptr);
	while(check == 128){
		len += 128;
		message = realloc(message, sizeof(unsigned char) * (len + 128));
		check = fread_s(message, sizeof(message), sizeof(unsigned char), 128, fptr);
	}
	len += check;
	fclose(fptr);
	
	//check if len is a multiple of 16, if not add some padding
	int remainder = len % 16;
	if(remainder > 0){
		int padding_n = 16 - remainder;
		int i;
		for(i=0; i < padding_n; i++)
			message[len+i] = 0x00;
		len += i;
	}
	
	memset(expandedKeys, 0x00, sizeof(expandedKeys));
	keyExpansion(key, expandedKeys);
	
	//main loop of cipher
	int i;
	for(i=0; i<len; i+=16)  // encrypt blocks of data
		AES_Encrypt(message+i, expandedKeys);
	
	err = fopen_s(&fptr, filepath, "wb");
	if(err == 22){
		printf("Error: file not accessible\n");
		return -1;
	}
	check = fwrite(message, sizeof(unsigned char), len, fptr);
	if(check < 1){
		printf("Error: couldn't write to file\n");
		return -1;
	}
	fclose(fptr);
	free(message);
	
	printf("Success: file successfully encrypted.")
	return 0;
}
